"""Base views for the other views of the site app."""

from collections import OrderedDict
from typing import Iterable, Sequence, Optional
from urllib import parse
from urllib.parse import parse_qsl

import Levenshtein
from django import forms
from django.conf import settings
from django.contrib import messages
from django.contrib.admin.models import ADDITION, CHANGE
from django.contrib.auth.mixins import PermissionRequiredMixin
from django.contrib.messages.storage import default_storage
from django.contrib.messages.views import SuccessMessageMixin
from django.core.exceptions import FieldDoesNotExist
from django.db import models, transaction
from django.http import Http404, HttpResponseBase
from django.shortcuts import redirect, render
from django.template.response import TemplateResponse
from django.urls import NoReverseMatch, reverse, reverse_lazy
from django.utils.http import urlencode
from django.utils.safestring import mark_safe
from django.utils.text import capfirst
from django.views.generic import ListView, UpdateView
from django.views.generic.base import ContextMixin
from mizdb_inlines.views import InlineFormsetMixin
from mizdb_tomselect.views import IS_POPUP_VAR, PopupResponseMixin
from mizdb_watchlist.views import WatchlistMixin

from dbentry.base.models import ComputedNameModel
from dbentry.csrf import CSRF_FORM_DATA_KEY, _restore_formset
from dbentry.search.forms import MIZSelectSearchFormFactory
from dbentry.search.mixins import SearchFormMixin
from dbentry.site.forms import InlineForm, MIZEditForm
from dbentry.site.registry import miz_site, Registry
from dbentry.site.templatetags.mizdb import add_preserved_filters
from dbentry.utils import flatten
from dbentry.utils.admin import construct_change_message, create_logentry
from dbentry.utils.html import create_hyperlink, get_obj_link, get_view_link
from dbentry.utils.models import get_model_relations
from dbentry.utils.permission import (
    get_perm,
    has_add_permission,
    has_change_permission,
    has_view_permission,
)
from dbentry.utils.text import diffhtml
from dbentry.utils.url import get_change_url, get_changelist_url_for_relation, get_view_url, urlname

# Constants for the changelist views
ALL_VAR = "all"
ORDER_VAR = "o"
PAGE_VAR = "p"
SEARCH_VAR = "q"

# The name of the input elements that hold the PK values of items that were
# selected for an action on a changelist.
ACTION_SELECTED_ITEM = "_selected-item"

# URLs for the index pages of the online and offline help.
ONLINE_HELP_INDEX = settings.ONLINE_HELP_URL
OFFLINE_HELP_INDEX = reverse_lazy("help", kwargs={"page_name": "index"})


def _email_configured():
    """Return whether the settings required for sending admin emails are set."""
    if settings.DEBUG:
        return True
    required_settings = [
        settings.ADMINS,
        settings.EMAIL_HOST != "localhost",
        settings.EMAIL_HOST_USER,
        settings.EMAIL_HOST_PASSWORD,
    ]
    return all(bool(s) for s in required_settings)


class BaseViewMixin(ContextMixin):
    """Mixin for all views of the `miz_site` site."""

    title: str = ""
    site: Registry = miz_site

    help_url: str = ""
    offline_help_url: str = ""

    def _get_admin_url(self, request):
        try:
            return self.get_admin_url(request)
        except NoReverseMatch:
            # No admin view for this view, try the admin index page instead.
            try:
                return reverse("admin:index")
            except NoReverseMatch:  # pragma: no cover
                return ""

    def get_admin_url(self, request):
        """Return the URL to the corresponding admin page for the given request."""
        match = request.resolver_match
        return reverse(f"admin:{match.url_name}", args=match.args, kwargs=match.kwargs)

    def get_help_url(self):
        """Return the URL to the corresponding online help page."""
        return self.help_url or ONLINE_HELP_INDEX

    def get_offline_help_url(self):
        """Return the URL to the corresponding offline help page."""
        return self.offline_help_url or OFFLINE_HELP_INDEX

    def get_feedback_url(self):
        if _email_configured():
            return reverse("feedback")
        return ""

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        ctx.update(
            {
                "title": self.title,
                "help_url": self.get_help_url(),
                "offline_help_url": self.get_offline_help_url(),
                "feedback_url": self.get_feedback_url(),
                "admin_url": self._get_admin_url(self.request),  # noqa
                "model_list": self.site.model_list,
                # Whether links generated by templates should open in a new tab
                "popup_links": False,
            },
        )
        return ctx


class ModelViewMixin(BaseViewMixin):
    """Mixin for views that interact with a model."""

    model: type[models.Model] = None  # type: ignore[assignment]
    opts = None
    pk_url_kwarg: str = "object_id"

    # Set to True if the model view has a corresponding help page. If False,
    # the help link will send the user to the help index page instead.
    view_has_help_page = True

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.opts = self.model._meta

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        ctx.update(
            {
                "model": self.model,
                "opts": self.model._meta,
                "preserved_filters": self.get_preserved_filters(self.request),  # noqa
            }
        )
        return ctx

    def get_preserved_filters(self, request):
        """Return the preserved filters query string of the given request."""
        match = request.resolver_match
        if match:
            opts = self.model._meta
            changelist_url = urlname("changelist", opts)
            if match.url_name == changelist_url:
                preserved_filters = request.GET.urlencode()
            else:
                preserved_filters = request.GET.get("_changelist_filters")

            if preserved_filters:
                return urlencode({"_changelist_filters": preserved_filters})
        return ""

    def get_help_url(self):
        """Return the URL to the corresponding online help page."""
        if not self.view_has_help_page:
            return ONLINE_HELP_INDEX
        return self.help_url or parse.urljoin(ONLINE_HELP_INDEX, f"{parse.quote(self.model._meta.model_name)}.html")

    def get_offline_help_url(self):
        """Return the URL to the corresponding offline help page."""
        if not self.view_has_help_page:
            return OFFLINE_HELP_INDEX
        return self.offline_help_url or reverse("help", kwargs={"page_name": self.model._meta.model_name})


class Inline:
    """
    Helper object for creating and managing inline formsets.

    The attributes `verbose_name_plural` and `verbose_name`, respectively,
    provide user-friendly labels for  the inline and the 'add another' button.
    Alternatively, set `verbose_model` to a model class with appropriate
    verbose_name and  verbose_name_plural meta attributes for the relation.

    The inline will be rendered in tabular form if attribute `tabular` is True.

    If the inline model is an M2M table, the inline will include template
    context items `changelist_url` and `changelist_fk_field`. Together with some
    javascript (added by InlineForm), this will add a link to the changelist
    of the related model.

    For most inlines, `changelist_url` and `changelist_fk_field` will be guessed
    correctly. If the inline model has more than three model fields, you will
    have to set `changelist_fk_field` attribute to the name of the ForeignKey
    field to the target model.
    Set `changelist_fk_field` to None to not have the link added.

    If a `changelist_fk_field` can be guessed from the inline model, or if it
    is set explicitly, the changelist will be filtered to only include the
    items selected in the inline (the changelist_fk_field must be rendered with
    a MIZSelect widget for this to work).

    The other attributes (model, form, fields, exclude, widgets) are arguments
    for the inline formset factory.
    """

    model: type[models.Model] = None  # type: ignore[assignment]
    form: forms.Form = InlineForm
    fields: Optional[Iterable[str]] = None
    exclude: Optional[Iterable[str]] = None
    widgets: Optional[dict[str, forms.Widget]] = None

    verbose_name: str = ""
    verbose_name_plural: str = ""
    verbose_model: type[models.Model] = None  # type: ignore[assignment]

    tabular: bool = True

    changelist_url: str = ""
    changelist_fk_field: str = ""

    def __init__(self, parent_model):
        self.parent_model = parent_model
        # verbose_name is used as the label of the 'add another' button.
        self.verbose_name = self._get_name("verbose_name")
        # verbose_name_plural is used as the label of the nav-tab
        self.verbose_name_plural = self._get_name("verbose_name_plural")

    def _get_name(self, attr):
        if getattr(self, attr):
            return getattr(self, attr)
        elif self.verbose_model:
            return getattr(self.verbose_model._meta, attr)
        else:
            return getattr(self.model._meta, attr)

    def get_context_data(self):
        """Return data for the template context."""
        return {
            "verbose_name": self.verbose_name,
            "verbose_name_plural": self.verbose_name_plural,
            "model_name": self.model._meta.model_name,
            "add_text": f"{self.verbose_name} hinzuf√ºgen",
            "tabular": self.tabular,
            "changelist_url": self.get_changelist_url(),
            "changelist_fk_field": self.get_changelist_fk_field(),
        }

    def get_formset_class(self):
        """Return the inline formset class."""
        return forms.inlineformset_factory(
            self.parent_model,
            self.model,
            form=self.form,
            # BaseInlineFormset.__init__ adds created InlineForeignKeyField
            # fields to `form._meta.fields`, which is the list passed to the
            # formset factory. To avoid unintended modification of the `fields`
            # attribute by passing a reference, pass a copy of it instead:
            fields=list(self.fields) if self.fields else forms.ALL_FIELDS,
            exclude=list(self.exclude) if self.exclude else None,
            widgets=self.widgets,
            extra=1,
        )

    def get_changelist_url(self):
        """Return the URL for the changelist button for this inline."""
        if self.changelist_url:
            return self.changelist_url
        if changelist_fk_field := self.get_changelist_fk_field():
            field = self.model._meta.get_field(changelist_fk_field)
            try:
                return reverse(urlname("changelist", field.related_model._meta))
            except NoReverseMatch:
                return ""
        else:
            return ""

    def get_changelist_fk_field(self):
        """
        Return the name of the field that contains the ids to be used in the
        URL of the changelist button.
        """
        if self.changelist_fk_field is None:
            # Do not create a changelist button.
            return ""
        if self.changelist_fk_field:
            return self.changelist_fk_field
        fields = self.model._meta.get_fields()
        if len(fields) == 3:
            # Can guess the field, assuming that the model contains these
            # fields: ID field, FK to parent, FK to target model
            for field in fields:
                if field.is_relation and field.related_model != self.parent_model:
                    return field.name
        return ""


class BaseEditView(
    WatchlistMixin,
    PopupResponseMixin,
    InlineFormsetMixin,
    SuccessMessageMixin,
    PermissionRequiredMixin,
    ModelViewMixin,
    UpdateView,
):
    """
    Base class for 'add' or 'change' views.

    Additional attributes:
        - inlines (list): a list of inline classes to include in the form
        - changelist_link_labels (dict): a mapping of related_model_name: label
          to give changelist_links custom labels
        - require_confirmation (bool): if true, changes that alter the objects
          string representation too much will require separate user confirmation
        - confirmation_threshold (float): the threshold for the Levenshtein
          ratio for which user confirmation for changes is required
    """

    template_name = "mizdb/change_form.html"

    exclude: Optional[Iterable] = None
    field_groups: Optional[Sequence] = None  # TODO: remove this attr - it is not used
    widgets: Optional[dict[str, forms.Widget]] = None
    form: forms.Form = MIZEditForm

    inlines: Sequence[type[Inline]] = ()
    changelist_link_labels: Optional[dict[str, str]] = None
    require_confirmation: bool = False
    confirmation_threshold: float = 0.85

    def __init__(self, *args, **kwargs):
        kwargs.setdefault("changelist_link_labels", getattr(self, "changelist_link_labels", {}))
        super().__init__(*args, **kwargs)
        self.add = self.extra_context["add"]

    def dispatch(self, request, *args, **kwargs):
        try:
            return super().dispatch(request, *args, **kwargs)
        except Http404:
            icon = """<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-alert-triangle"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>"""  # noqa
            pk = self.kwargs.get(self.pk_url_kwarg)
            messages.warning(
                request,
                mark_safe(f"{icon} {self.opts.verbose_name} mit ID '{pk}' existiert nicht. Vielleicht gel√∂scht?"),
            )
            redirect_url = add_preserved_filters(
                {"opts": self.opts, "preserved_filters": self.get_preserved_filters(self.request)},
                reverse(urlname("changelist", self.opts)),
            )
            return redirect(redirect_url)

    def get(self, request, *args, **kwargs):
        if self.extra_context.get("view_only", False):
            return self.view_only(request)
        if CSRF_FORM_DATA_KEY in request.session:
            # This is the data of a POST request that failed due to an invalid
            # CSRF token. Add a reference to the data of the failed form, so
            # that it can be restored.
            self.csrf_form_data = request.session.pop(CSRF_FORM_DATA_KEY)  # noqa
        return super().get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        if not self.add and self.require_confirmation:
            return self.handle_require_confirmation(request, *args, **kwargs)
        return super().post(request, *args, **kwargs)

    def has_permission(self):
        if self.extra_context.get("view_only", False):
            perm_func = has_view_permission
        elif self.add:
            perm_func = has_add_permission
        else:
            perm_func = has_change_permission
        return perm_func(self.request.user, self.opts)

    def get_inline_instances(self):
        return [inline_cls(self.model) for inline_cls in self.inlines]

    def get_formset_classes(self):
        return [inline.get_formset_class() for inline in self.get_inline_instances()]

    def get_fields(self):
        """Return the list of fields to include in the model form."""
        return self.fields or forms.ALL_FIELDS

    def get_exclude(self):
        """Return the list of fields to exclude from the model form."""
        # Exclude M2M fields.
        exclude = self.exclude or []
        for field in self.opts.get_fields():
            if field.concrete and field.many_to_many:
                exclude.append(field.name)
        return exclude

    def get_widgets(self):
        """Hook for overriding model form widgets."""
        # None is the correct default for the form factory here.
        # Passing an empty dict instead would override widgets set on the
        # form class.
        return self.widgets or None

    def get_form_class(self):
        """Return a model form class."""
        return forms.modelform_factory(
            model=self.model,
            form=self.form,
            fields=self.get_fields(),
            exclude=self.get_exclude(),
            widgets=self.get_widgets(),
        )

    def get_permission_required(self):
        """Return the permission <app_label>.<codename> required for this view."""
        action = "add" if self.add else "change"
        return [get_perm(action, self.opts)]

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        if self.add:
            ctx["title"] = f"{capfirst(self.opts.verbose_name)} hinzuf√ºgen"
        else:
            ctx["title"] = capfirst(self.opts.verbose_name)
        ctx["popup_links"] = True  # open links in a new tab
        ctx["field_groups"] = self.field_groups
        ctx["inlines"] = list(
            zip(
                ctx["formsets"],
                [inline.get_context_data() for inline in self.get_inline_instances()],
            )
        )
        if not self.add:
            ctx["changelist_links"] = self.get_changelist_links(self.changelist_link_labels)
        ctx["has_errors"] = (
            ctx["form"].errors or ctx["form"].non_field_errors() or any(fs.errors for fs in ctx["formsets"])
        )
        return ctx

    def get_object(self, queryset=None):
        if not self.add:
            return super().get_object(queryset)

    def get_success_url(self):
        """
        Return the success_url that corresponds with the submit button that was
        pressed.

        The submit buttons add a little 'extra_data' to the request:
          - 'add_another' -> return the same view with an empty form
          - 'continue' -> show the change form of the current object
          - 'add' -> return to the changelist (default)

        Ignore the success_url if the page was a mizdb-tomselect popup.
        """
        if IS_POPUP_VAR in self.request.POST or IS_POPUP_VAR in self.request.GET:
            return ""
        if "_addanother" in self.request.POST:
            url = reverse(urlname("add", self.opts))
        elif "_continue" in self.request.POST:
            url = reverse(urlname("change", self.opts), args=[self.object.pk])
        else:
            try:
                url = reverse(urlname("changelist", self.opts))
            except NoReverseMatch:  # pragma: no cover
                # Some edit views may not have a corresponding changelist.
                return reverse("index")
        return add_preserved_filters(
            {"opts": self.opts, "preserved_filters": self.get_preserved_filters(self.request)}, url
        )

    def get_initial(self):
        """Use GET parameters for initial form data."""
        initial = dict(self.request.GET.items())
        # Add preserved changelist filters:
        if self.add and "_changelist_filters" in self.request.GET:
            initial.update(dict(parse_qsl(self.request.GET["_changelist_filters"])))
        if hasattr(self, "csrf_form_data"):
            # Handling a CSRF failure: add data to restore the form.
            select_multiple = (forms.MultipleChoiceField, forms.ModelMultipleChoiceField)
            for field in self.get_form_class().base_fields:
                if field in self.csrf_form_data:
                    value = self.csrf_form_data[field]
                    if not isinstance(field, select_multiple) and isinstance(value, list):
                        value = value[0]
                    initial[field] = value
        return initial

    def get_formsets(self, parent_instance):
        """Return a list of formset instances."""
        formsets = []
        kwargs = self.get_formset_kwargs()
        kwargs["instance"] = parent_instance
        for formset_class in self.get_formset_classes():
            formset = formset_class(**kwargs)
            if hasattr(self, "csrf_form_data"):
                # Handling a CSRF failure: restore the formset.
                formset = _restore_formset(formset, getattr(self, "csrf_form_data"))
            formsets.append(formset)
        return formsets

    def post_save(self, form, formsets):
        # Hook called by InlineFormsetMixin.
        if isinstance(self.object, ComputedNameModel):
            # Update the instance's name after its related objects have been
            # saved.
            self.object.update_name(force_update=True)
        create_logentry(
            user_id=self.request.user.pk,
            obj=form.instance,
            action_flag=ADDITION if self.add else CHANGE,
            message=construct_change_message(form, formsets, self.add),
        )

    def get_changelist_link_relations(self):
        """
        Return a list of relations for which to create changelist links.

        Exclude relations already covered by inlines.
        """
        relations = []
        inline_models = [inline.model for inline in self.inlines] if self.inlines else []
        for rel in get_model_relations(self.model, forward=False, reverse=True):
            if rel.many_to_many:
                inline_model = rel.through
            else:
                inline_model = rel.related_model
            if inline_model in inline_models:
                continue
            relations.append(rel)
        return relations

    def get_changelist_links(self, labels=None):
        """
        Return a list of changelist URLs (and link labels) to the related
        objects of this view's object.
        """
        links = []

        def url_callback(query_model):
            return reverse(urlname("changelist", query_model._meta))

        for rel in self.get_changelist_link_relations():
            url, count, label = get_changelist_url_for_relation(rel, self.model, self.object.pk, url_callback, labels)
            if url and count:
                links.append((url, label, count))
        return links

    def handle_require_confirmation(self, request, *args, **kwargs):
        """This view requires a confirmation for big changes to the model object."""
        if "_change_confirmed" in request.POST:
            # Restore the original form data.
            request.POST = request.session.pop("confirmed_form_data", request.POST)
            return super().post(request, *args, **kwargs)
        else:
            initial = self.get_object()
            before = str(initial)
            with transaction.atomic():
                response = super().post(request, *args, **kwargs)
                after = str(self.object)
                ratio = Levenshtein.ratio(before, after)
                if ratio < self.confirmation_threshold:
                    # The object's name has changed significantly; require the
                    # user to confirm the changes before saving.
                    transaction.set_rollback(True)
                    # Clear the "saved successfully" message:
                    request._messages = default_storage(request)
                    # Save the form data to be used after the confirmation:
                    request.session["confirmed_form_data"] = request.POST
                    distance = Levenshtein.distance(before, after)
                    context = {
                        **super(ModelViewMixin, self).get_context_data(),
                        "title": "√Ñnderungen best√§tigen",
                        "link": get_obj_link(request, initial, blank=True),
                        "before": before,
                        "after": after,
                        "distance": distance,
                        "ratio": f"{ratio:.0%}",
                        "diff": mark_safe(diffhtml(before, after)),
                    }
                    return TemplateResponse(request, "mizdb/change_confirmation.html", context=context)
                else:
                    # Changes are not big enough to require a confirmation.
                    return response

    def get_success_message(self, cleaned_data):
        if IS_POPUP_VAR in self.request.POST or IS_POPUP_VAR in self.request.GET:
            return ""
        icon = """<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check"><polyline points="20 6 9 17 4 12"></polyline></svg>"""  # noqa
        if self.add:
            return mark_safe(
                f"{icon} {self.opts.verbose_name} '{get_obj_link(self.request, self.object)}' erfolgreich erstellt."
            )
        else:
            return mark_safe(
                f"{icon} {self.opts.verbose_name} '{get_obj_link(self.request, self.object)}' erfolgreich ge√§ndert."
            )

    def view_only(self, request):
        """
        Display the object read-only (without a form) for users with view
        permissions.
        """
        self.object = self.get_object()  # noqa
        ctx = self.get_context_data()
        ctx["view_only"] = True
        ctx["data"] = self.get_object_data_dict(self.request, ctx["form"], ctx["inlines"])
        return render(request, "mizdb/viewonly.html", ctx)

    @staticmethod
    def get_object_data_dict(request, form, inlines):
        """
        Return a dictionary version of the view's object to be used in the
        view-only mode.

        The values of the dictionary are strings derived from the form and the
        inlines formsets.
        """

        def stringify_boundfield(bf):
            """
            Return a string representation of the value(s) of the given boundfield.
            """  # noqa: D200
            formfield = bf.field
            value = boundfield.value()
            if isinstance(formfield, forms.ChoiceField) and value:
                # Return the human-readable part of the selected choices.
                if isinstance(formfield, (forms.MultipleChoiceField, forms.ModelMultipleChoiceField)):
                    selected = value
                else:
                    selected = [value]
                if isinstance(formfield, forms.ModelChoiceField):
                    return ", ".join(
                        get_view_link(request, o, blank=True) for o in bf.field.queryset.filter(pk__in=selected)
                    )
                return ", ".join(dict(formfield.choices)[s] for s in selected)
            elif isinstance(formfield.widget, forms.URLInput) and value:
                return create_hyperlink(value, value, target="_blank")
            elif isinstance(formfield, forms.BooleanField):
                if value:
                    return "Ja"
                else:
                    return "Nein"
            else:
                return value or empty_value_display

        data = OrderedDict()
        empty_value_display = "---"
        for boundfield in form:
            if boundfield.is_hidden:
                continue
            data[boundfield.label] = mark_safe(stringify_boundfield(boundfield))

        for formset, inline_opts in inlines:
            formset_value = ""
            form_values = []
            for form in formset.forms:
                field_values = []
                for boundfield in form:
                    if boundfield.is_hidden or boundfield.value() in boundfield.field.empty_values:
                        continue
                    field_value = mark_safe(stringify_boundfield(boundfield))
                    # Assume that the inline verbose name is descriptive enough
                    # for the first field. For inlines with more than one field,
                    # include the label of the field.
                    if field_values:
                        # field_values is not empty: this form contains more
                        # than one field.
                        field_value = f"{boundfield.label}:  {field_value}"
                    field_values.append(field_value)
                form_values.append("; ".join(field_values))

            formset_value += "\n".join(form_values)
            data[inline_opts["verbose_name_plural"]] = mark_safe(formset_value) or empty_value_display
        return data


class BaseListView(WatchlistMixin, PermissionRequiredMixin, ModelViewMixin, ListView):
    """
    Base view for displaying a list of model objects ("changelist").

    Set attribute `list_display` to control which fields are displayed on the
    changelist.

    Additional attributes:
        - order_unfiltered_results (bool): if True, apply ordering to unfiltered
          changelist querysets. Setting this to False will only apply 'id'
          ordering to an unfiltered queryset. This is useful for speeding up
          the initial request for a changelist.
        - prioritize_search_ordering (bool): if True, do not override the
          ordering set by queryset.search()
        - actions (list): a list of changelist action callables
        - sortable_by (list): defines which list_display fields the changelist
          can be sorted against. If left empty, the changelist can be sorted
          against all fields.
        - include_add_btn (bool): if False, the changelist will not display an
          add button for the given model
    """

    template_name: str = "mizdb/changelist.html"
    list_display: Sequence[str] = ()
    list_display_links: Sequence[str] = ()
    paginate_by: int = 100
    empty_value_display: str = "-"
    page_kwarg: str = PAGE_VAR

    order_unfiltered_results: bool = True
    prioritize_search_ordering: bool = True
    actions: Sequence = ()
    sortable_by: Sequence[str] = ()
    include_add_btn = True

    def has_permission(self):
        return has_view_permission(self.request.user, self.opts)

    def get_ordering_field(self, field_name):
        """
        Return the proper model field name corresponding to the given
        field_name to use for ordering. field_name may either be the name of a
        proper model field or the name of a method on the view with the
        'order_field' attribute.

        Return None if no proper model field name can be matched.
        """
        try:
            field = self.opts.get_field(field_name)
            return field.name
        except FieldDoesNotExist:
            # See whether field_name is a name of a non-field
            # that allows sorting.
            if hasattr(self, field_name):
                attr = getattr(self, field_name)
                return getattr(attr, "ordering", None)

    def get_query_string(self, new_params=None, remove=None):
        """
        Add or remove query parameters from the current request, and return the
        url encoded new query string.
        """
        # Used by template tag paginator_url
        if new_params is None:
            new_params = {}
        if remove is None:
            remove = []
        p = dict(self.request.GET.items()).copy()
        for r in remove:
            for k in list(p):
                if k.startswith(r):
                    del p[k]
        for k, v in new_params.items():
            if v is None:
                if k in p:
                    del p[k]
            else:
                p[k] = v
        return "?%s" % urlencode(sorted(p.items()))

    def get_queryset(self):
        queryset = self.add_list_display_annotations(super().get_queryset())
        queryset = self.get_search_results(queryset)

        # Re-evaluate the ordering of the queryset, now that the search was
        # performed and annotations have been added.
        return self.order_queryset(queryset)

    @property
    def search_term(self):
        return self.request.GET.get(SEARCH_VAR, "")

    def get_search_results(self, queryset):
        if self.search_term:
            return queryset.search(self.search_term, ranked=ORDER_VAR not in self.request.GET)
        return queryset

    def _get_default_ordering(self):
        if self.ordering is not None:
            return self.ordering
        elif self.opts.ordering:
            return self.opts.ordering
        else:
            return []

    def get_ordering_fields(self, queryset):
        """Return the list of ordering fields for the results queryset."""
        if self.prioritize_search_ordering and self.search_term:
            # queryset.search has applied its own ordering, do not override:
            return queryset.query.order_by
        else:
            ordering = [*self._get_default_ordering()]
            ordering.extend(queryset.query.order_by)
            ordering.append(self.opts.pk.name)
            return ordering

    def order_queryset(self, queryset):
        if ORDER_VAR in self.request.GET:
            ordering = []
            for p in self.request.GET[ORDER_VAR].split("."):
                try:
                    _, pfx, idx = p.rpartition("-")
                    field_name = self.list_display[int(idx)]
                    order_field = self.get_ordering_field(field_name)
                    if not order_field:
                        continue  # No 'admin_order_field', skip it
                    # reverse order if order_field has already "-" as prefix
                    if order_field.startswith("-") and pfx == "-":
                        ordering.append(order_field[1:])
                    else:
                        ordering.append(pfx + order_field)
                except (IndexError, ValueError):  # pragma: no cover
                    continue  # Invalid ordering specified, skip it.
        elif not (queryset.query.has_filters() or self.order_unfiltered_results):
            # Do not apply (expensive) ordering on an unfiltered queryset.
            ordering = [self.opts.pk.name]
        else:
            ordering = self.get_ordering_fields(queryset)
        return queryset.order_by(*ordering)

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)
        paginator = ctx["paginator"]

        # Collect the actions.
        # Differentiate between the standard actions (delete, merge, watchlist
        # export, export_results) and other, additional actions.
        delete_action = merge_action = watchlist_action = export_action = export_results_action = None
        other_actions = []
        for name, (_func, text, title) in self.get_actions().items():
            action = {"name": name, "text": text, "title": title}
            if name == "delete":
                delete_action = action
            elif name == "merge_records":
                merge_action = action
            elif name == "watchlist":
                watchlist_action = action
            elif name == "export":
                export_action = action
            elif name == "export_results":
                export_results_action = action
            else:
                other_actions.append(action)
        actions = {
            "delete_action": delete_action,
            "merge_action": merge_action,
            "watchlist_action": watchlist_action,
            "export_action": export_action,
            "export_results_action": export_results_action,
            "other_actions": other_actions,
        }

        ctx.update(
            {
                "title": self.opts.verbose_name_plural,
                # some template tags require this view object:
                "cl": self,
                # call list on the pagination page range generator, because it will
                # be consumed more than once:
                "page_range": list(paginator.get_elided_page_range(ctx["page_obj"].number)),
                "pagination_required": paginator.count > 100,
                "result_rows": self.get_result_rows(ctx["object_list"]),
                "result_headers": self.get_result_headers(),
                "result_count": self.object_list.count(),
                "total_count": self.model.objects.count(),
                "search_term": self.request.GET.get(SEARCH_VAR, ""),
                "actions": actions,
                "is_filtered": bool(ctx["object_list"].query.has_filters()),
                "include_add_btn": self.include_add_btn,
            }
        )
        # Provide the template with the URL for the view that syncs the
        # changelist selection:
        try:
            ctx["cls_sync_url"] = reverse("changelist_selection_sync")
        except NoReverseMatch:
            pass
        return ctx

    def get_empty_value_display(self):
        """Return the empty_value_display set on this view."""
        return mark_safe(self.empty_value_display)

    def _lookup_field(self, name):
        """
        Get the model field or view callable for the given name, and return it
        and an appropriate label.
        """
        attr = getattr(self, name, None)
        if attr is not None and hasattr(attr, "description"):
            # This is a view (display) callable with a description attribute.
            return attr, attr.description
        try:
            attr = self.opts.get_field(name)
        except FieldDoesNotExist:
            # This is not a model field either!
            label = name
        else:
            if attr.verbose_name[0].isupper():
                # This is probably a verbose name set by the user and not just
                # the default which starts with a lower letter.
                return attr, attr.verbose_name
            label = name
        return attr, label.replace("_", " ").capitalize()

    def get_ordering_field_columns(self):
        """
        Return a dictionary of ordering field column numbers and asc/desc.

        The dictionary is used in the table headers of the result list to
        indicate the sorting.
        """
        ordering_fields = {}
        if ORDER_VAR not in self.request.GET:
            for field in self._get_default_ordering():
                if field.startswith("-"):
                    field = field[1:]
                    order_type = "desc"
                else:
                    order_type = "asc"
                # Determine the list display index of this field:
                for index, attr in enumerate(self.list_display):
                    # Get the ordering field for this list display item:
                    try:
                        # Model field
                        ordering_field = self.opts.get_field(attr).name
                    except FieldDoesNotExist:
                        # View callable
                        ordering_field = getattr(getattr(self, attr, None), "ordering", None)
                        if ordering_field and ordering_field.startswith("-"):
                            ordering_field = ordering_field[1:]
                    if ordering_field == field:
                        ordering_fields[index] = order_type
                        break
        else:
            for p in self.request.GET[ORDER_VAR].split("."):
                _, pfx, idx = p.rpartition("-")
                try:
                    idx = int(idx)
                except ValueError:  # pragma: no cover
                    continue  # skip it
                ordering_fields[idx] = "desc" if pfx == "-" else "asc"
        return ordering_fields

    def get_result_headers(self):
        """Return the headers for the result list table."""
        headers = []
        for i, name in enumerate(self.list_display or ["__str__"]):
            if name == "__str__":
                headers.append({"text": self.model._meta.verbose_name})
            else:
                attr, label = self._lookup_field(name)
                sortable_by = self.get_sortable_by()
                if sortable_by and name not in sortable_by or callable(attr) and not hasattr(attr, "ordering"):
                    # Either this list_display item is not included in
                    # sortable_by, or the item is a view method without an
                    # ordering field; not sortable.
                    headers.append({"text": label, "sortable": False})
                    continue
                # Either a model field (which we assume to be sortable) or a
                # view method that declares an ordering field.
                ordering_field_columns = self.get_ordering_field_columns()
                order_type = ""
                new_order_type = "asc"
                sort_priority = 0
                # Is it currently being sorted on?
                is_sorted = i in ordering_field_columns
                if is_sorted:
                    order_type = ordering_field_columns.get(i).lower()
                    sort_priority = list(ordering_field_columns).index(i) + 1
                    new_order_type = {"asc": "desc", "desc": "asc"}[order_type]

                # build new ordering param
                o_list_primary = []  # URL for making this field the primary sort
                o_list_remove = []  # URL for removing this field from sort
                o_list_toggle = []  # URL for toggling order type for this field

                def make_qs_param(t, n):
                    return ("-" if t == "desc" else "") + str(n)

                for j, ot in ordering_field_columns.items():
                    if j == i:  # Same column
                        param = make_qs_param(new_order_type, j)
                        # We want clicking on this header to bring the ordering to the
                        # front
                        o_list_primary.insert(0, param)
                        o_list_toggle.append(param)
                        # o_list_remove - omit
                    else:
                        param = make_qs_param(ot, j)
                        o_list_primary.append(param)
                        o_list_toggle.append(param)
                        o_list_remove.append(param)

                if i not in ordering_field_columns:
                    o_list_primary.insert(0, make_qs_param(new_order_type, i))

                def add_params(new_params):
                    params = {**dict(self.request.GET.items()), **new_params}
                    return f"?{urlencode(params)}"

                headers.append(
                    {
                        "text": label,
                        "sortable": True,
                        "sorted": is_sorted,
                        "ascending": order_type == "asc",
                        "sort_priority": sort_priority,
                        "url_primary": add_params({ORDER_VAR: ".".join(o_list_primary)}),
                        "url_remove": add_params({ORDER_VAR: ".".join(o_list_remove)}),
                        "url_toggle": add_params({ORDER_VAR: ".".join(o_list_toggle)}),
                    }
                )
        return headers

    def add_list_display_annotations(self, queryset):
        """Add annotations for list_display items to the given queryset."""
        if hasattr(queryset, "overview"):
            return queryset.overview()
        return queryset

    def get_result_rows(self, object_list):
        """
        For each result in object_list, return a 2-tuple of (object, result_row),
        where result_row are the values to display in the row of a given result.
        """
        return [(r, self.get_result_row(r)) for r in object_list]

    def get_result_row(self, result):
        """Return the values to display in the row for the given result."""

        def link_in_col(is_first, field_name):
            if self.list_display_links is None:
                return False
            if is_first and not self.list_display_links:
                return True
            return field_name in self.list_display_links

        result_items = []
        first = True
        # Choose the right URL function for the links, depending on permissions.
        url_func = get_view_url
        if has_change_permission(self.request.user, self.opts):
            url_func = get_change_url

        for name in self.list_display or ["__str__"]:
            if name == "__str__":
                value = str(result)
            else:
                attr, _label = self._lookup_field(name)
                if callable(attr):
                    value = attr(result)
                else:
                    # Assume that this is a model field.
                    if isinstance(attr, models.ForeignKey):
                        value = getattr(result, attr.name)
                        if value is not None:
                            value = str(value)
                    else:
                        value = getattr(result, attr.attname)
                    if getattr(attr, "flatchoices", None):  # pragma: no cover
                        # Use the human-readable part of the choice:
                        value = dict(attr.flatchoices).get(value, "")
            if not value and value not in (0, False):
                value = self.get_empty_value_display()
            if link_in_col(first, name) and url_func:
                try:
                    url = add_preserved_filters(
                        {"opts": self.opts, "preserved_filters": self.get_preserved_filters(self.request)},
                        url_func(self.request, result),
                    )
                except NoReverseMatch:
                    pass
                else:
                    if url:
                        value = create_hyperlink(url, value, **{"class": "change-link"})
            result_items.append(value)
            first = False
        return result_items

    def get_actions(self):
        """
        Return a dictionary of the changelist actions available to the user.

        The dictionary's keys are the "internal names" of the actions.
        The values are 3-tuples of (view function, label text, description).
        """
        from dbentry.site.views import actions as _actions

        actions = OrderedDict()
        base_actions = [_actions.delete, _actions.merge_records, _actions.watchlist]
        if getattr(self, "resource_class", None):
            base_actions.extend([_actions.export, _actions.export_results])
        for action in base_actions + list(self.actions):
            name = action.__name__
            has_permission = getattr(action, "has_permission", None)
            label = getattr(action, "label", name)
            description = getattr(action, "description", "")
            if callable(has_permission) and not has_permission(self.request.user, self.opts):
                continue
            actions[name] = (action, label, description)
        return actions

    def post(self, request, *_args, **_kwargs):
        """Handle a changelist action."""
        try:
            selected_action = request.POST["action_name"]
            func, _text, _title = self.get_actions()[selected_action]
        except KeyError:
            # Unknown action.
            messages.warning(request, "Abgebrochen: unbekannte Aktion ausgew√§hlt.")
            return redirect(request.get_full_path())

        if func.__name__ == "export_results":
            # This is the 'export all search results' action which is applied
            # to all search results and not just the selected items.
            queryset = self.get_queryset()
        else:
            selected = request.POST.getlist(ACTION_SELECTED_ITEM)
            queryset = self.model.objects.filter(pk__in=selected)
        if not queryset.exists():
            messages.warning(request, "Abgebrochen: keine Objekte ausgew√§hlt.")
            return redirect(request.get_full_path())

        response = func(self, request, queryset)
        if isinstance(response, HttpResponseBase):
            # Show the response returned by the action.
            return response
        else:
            # The action did not return a response; redirect back to the
            # changelist.
            return redirect(request.get_full_path())

    def get_sortable_by(self):
        return self.sortable_by


class SearchableListView(SearchFormMixin, BaseListView):
    """
    A BaseListView with a search form.

    Configure the search form via the attribute `search_form_kwargs`.
    """

    searchform_factory = MIZSelectSearchFormFactory()

    def get_search_results(self, queryset):
        """Filter the queryset with the search form filters."""
        queryset = super().get_search_results(queryset)
        search_form = self.get_search_form(data=self.request.GET)
        if search_form.is_valid():
            queryset = queryset.filter(**self.get_filters(search_form))
        return queryset

    def get_filters(self, search_form):
        filters = {}
        for key, value in search_form.get_filters_params().items():
            if key.endswith("__in"):
                value = value.split(",")
            elif key.endswith("__isnull"):
                value = value.lower() not in ("", "false", "0")
            filters[key] = value
        return filters

    def get_context_data(self, **kwargs):
        ctx = super().get_context_data(**kwargs)

        # Show fields with values directly, but keep empty fields in the
        # collapsed container.

        def is_empty(bound_field):
            value = bound_field.value()
            if isinstance(value, bool) and not value:
                return True
            elif value in bound_field.field.empty_values:
                return True
            elif isinstance(bound_field.field, forms.MultiValueField):
                # The value for an empty MultiValueField can look like this:
                # - [None, None] or
                # - [[None, None], [None, None]] (nested MultiValueFields, i.e. PartialDate + RangeField)  # noqa: W505
                return all(subvalue is None for subvalue in flatten(value))
            else:
                return False

        ctx["shown_fields"] = []
        ctx["collapsed_fields"] = []
        for field in ctx["advanced_search_form"]:
            if is_empty(field):
                ctx["collapsed_fields"].append(field)
            else:
                ctx["shown_fields"].append(field)
        return ctx
